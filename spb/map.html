<!DOCTYPE html>
<html>
<head>
    <title>Транспорт СПб</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <script src="//api-maps.yandex.ru/2.1/?lang=ru_RU" type="text/javascript"></script>
	<script type="text/javascript" src="https://yastatic.net/jquery/2.2.0/jquery.min.js"></script>
    <script type="text/javascript">
    	function rgb2hsl(rgb) {
	        var r = rgb[0],
	            g = rgb[1],
	            b = rgb[2],
	            l = Math.max(r, g, b),
	            d = l - Math.min(r, g, b),
	            s = d/l,
	            h;

	        if(l == r) {
	            if(g <= b) {
	                h = (g - b) / 6;
	            }
	            else {
	                h = (g - b) / 6 / d;
	            }
	        }
	        if(l == g) {
	            h = (b - r) / 6 / d + 1/3;
	        }
	        if(l == b) {
	            h = (r - g) / 6 / d + 2/3;
	        }
	        h > 1 && h--;
	        h < 0 && h++;

	        return [h, s, l];
	    }

	    function hsl2rgb(hsl) {
	        var h = hsl[0] - Math.floor(hsl[0]),
	            s = hsl[1],
	            l = hsl[2];

	        if (!s) return [l, l, l]

	        h *= 6;
	        var i = Math.floor(h),
	            data = [1-s, 1-s*(h-i), 1-s*(1-(h-i)), 1],
	            picks = [
	                [3, 2, 0],
	                [1, 3, 0],
	                [0, 3, 2],
	                [0, 1, 3],
	                [2, 0, 3],
	                [3, 0, 1]
	            ];

	        return picks[i].map(function(pick) {
	            return l * data[pick];
	        });
	    }

	    function formatColor(rgb) {
	        r = (rgb[0] * 256) | 0;
	        g = (rgb[1] * 256) | 0;
	        b = (rgb[2] * 256) | 0;
	        return '#' + ('0' + r.toString(16)).substr(-2) + ('0' + g.toString(16)).substr(-2) + ('0' + b.toString(16)).substr(-2);
	    }

	    function mixColor(a, b, q) {
	        a = hsl2rgb(a);
	        b = hsl2rgb(b);
	        return rgb2hsl([
	            (1-q) * a[0] + q * b[0],
	            (1-q) * a[1] + q * b[1],
	            (1-q) * a[2] + q * b[2]
	        ]);
	    }

	    function frame(val, from, to) {
	        var res = from + val * (to - from);
	        return res - Math.floor(res);
	    }

	    function getColor(bus) {
	        bus = bus + '';
	        var type = 2,
	            k = false;
	        if(bus.indexOf('Тб') != -1) {
	            bus = bus.substr(3);
	            type = 1;
	        }
	        if(bus.indexOf('Тм') != -1) {
	            bus = bus.substr(3);
	            type = 0;
	        }
	        if(bus.indexOf('Мт') != -1) {
	            bus = bus.substr(3);
	            type = 3;
	        }
	        if(bus.indexOf('Э') != -1) {
	            bus = bus.replace(/э/g, '');
	            type = 3;
	        }
	        if(/.?[a-яA]$/.test(bus)) {
	            bus = bus.substr(0, bus.length - 1);
	            k = true;
	        }
		        bus = +bus.replace(/^[^\d]/g, '');
	        if(isNaN(bus)) {
	            bus = 0;
	        }
	        var color = [
	            ((bus + 2) % 11) / 10,
	            0.09 + 0.2 * ((bus / 16) % 4),
	            0.48 + 0.09 * (bus % 5)
	        ],
	        z = [];

	        switch (type) {
	            case 0:
	                color[0] = frame(color[0], -0.1, 0.05);
	                color[1] = frame(color[1], 0.75, 1);
	                color[2] = frame(color[2], 1 - (color[1] - 0.75) * 3, 1);
	                break;
	            case 1:
	                color[0] = frame(color[0], 0.2, 0.4);
	                color[1] = frame(color[1], 0.7 + 0.3 * Math.abs(color[0] - 0.3), 1);
	                color[2] = frame(color[2], 0.3, 1);
	                break;
	            case 2:
	                color[0] = frame(color[0], 0.4 + color[1] / 4, 1 - color[1] / 4);
	                color[1] = frame(color[1], 0, 1 - 0.5 * Math.abs(color[0] - 0.8));
	                color[2] = frame(color[2], 0, 1 - 0.3 * Math.abs(color[0] - 0.8));
	                break;
	            case 3:
	                color[0] = frame(color[0], 0.1, 0.14);
	                color[1] = frame(color[1], 0.9, 1);
	                color[2] = frame(color[2], 1 - (color[1] - 0.75) * 2, 1);
	                break;
	        }
	        if(k) {
	            color[1] = frame(color[1], 0, 0.9);
	            color[2] = frame(color[2], 0.3, 1);
	        }
	        return formatColor(hsl2rgb(color));
	    }

		ymaps.ready(function () {
		    var myMap = new ymaps.Map('map', {
		            center: [59.9, 30.4],
		            zoom: 9,
		            controls: []
		        }),
		    	coll = new ymaps.GeoObjectCollection();

	    	myMap.layers.add(new ymaps.Layer('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="256" height="256"><rect x="0" y="0" width="256" height="256" fill="rgba(255, 255, 255, 0.7)"/></svg>', { tileTransparent: true }));

	   		Promise.all([
    			fetch('./rgam-spb.json').then(function(res) { return res.json() }),
    			fetch('./buses.json').then(function(res) { return res.json() }),
    			fetch('./trolls.json').then(function(res) { return res.json() }),
    			fetch('./trams.json').then(function(res) { return res.json() }),
    			fetch('./mt.json').then(function(res) { return res.json() }),
    		]).then(function(res) {
    			var [rgam, buses, trolls, trams, mt] = res,
    				data = { ...buses, ...trolls, ...trams, ...mt },
    				sortedData = Object.keys(data).reduce((sortedData, number) => {
    					var val = data[number],
    						width = val.tts[0] && val.tts[0].length;

	    				if (!width) {
	    					width = rgam[number] && rgam[number].quantity && (rgam[number].quantity / rgam[number].length) * 90;
	    				}
	    				if (!width) {
	    					width = 30;
	    				}

	    				sortedData.push({ number, width, ...val });
	    				return sortedData;
    				}, []).sort((a, b) => a.width - b.width);

				sortedData.forEach((val, i) => {
					[val.forward, val.backward].filter(Boolean).forEach(line => {
						var polyline = new ymaps.Polyline(
							line,
							{
								balloonContent: val.number,
								color: getColor(val.number),
								opacity: val.width / 800,
								zIndex: 40 + i * 2
							}, {
						 		strokeColor: getColor(val.number),
						 		strokeOpacity: val.width / 800,
						 		strokeWidth: 3,
						 		zIndex: 40 + i * 2
						 	}
					 	);

						polyline.events.add('balloonopen', onPolylineBalloonOpen);
						polyline.events.add('balloonclose', onPolylineBalloonClose);
						coll.add(polyline);
					});
				});

				myMap.geoObjects.add(coll);
			});
		});

		function onPolylineBalloonOpen(e) {
			var target = e.get('target');

			target.options.set({
				strokeWidth: [15, 10],
				strokeColor: ['ffff', target.properties.get('color')],
				strokeOpacity: 1,
				zIndex: 9000
			});
		}

		function onPolylineBalloonClose(e) {
			var target = e.get('target');

			target.options.set({
				strokeWidth: 3,
				strokeColor: target.properties.get('color'),
				strokeOpacity: target.properties.get('opacity'),
				zIndex: target.properties.get('zIndex')
			});
		}
    </script>
	<style>
        html, body, #map {
            width: 100%; height: 100%; padding: 0; margin: 0;
        }
    </style>
</head>
<body>
<div id="map"></div>
</body>
</html>
